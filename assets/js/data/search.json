[ { "title": "用 Flask 和 100 行代码写一套 REST API", "url": "/posts/simple-restful-api-in-100-lines-code-using-flask/", "categories": "Python", "tags": "flask", "date": "2016-04-29 11:22:33 +0800", "snippet": "最近在写后台时用到了 Flask 框架。作为 Python 刚接触不久的初学者，Flask 带来了极大的满足感。首先是小巧简洁，对于需求只是搭建一小套 API 来说，用上全功能的 Django 框架未免太“重了。组件搭配灵活，给开发者充分的自由度。蓝图(Blueprints)设计也提供了更大的扩展潜力。当然你也可以把上述两条看作缺点，毕竟面对众多 Flask 模块也有一定的试错成本。另外 Flask 的中文资料十分稀少且落后，一定要阅读英文文档。本文涉及的主题并不高深，仅仅是强调减轻开发负担的最佳实践和模式。尽量避免啰嗦官方文档中提到的内容。如果你想尝试它们，一定会有对阅读官方文档的急迫需求（这不错吧？）。组织模式单一模块由于项目功能比较简单，只是实现一套小型 API，大部分代码都放到了单一文件 app.py 中。对于一些微项目来说这恰到好处，毕竟只需要处理几个路由（route）并且只有百来行代码。整个项目的结构看起来像这样：app.pyconfig.pyschedule.pyrequirements.txtstatic/templates/如果需要开发一个更加复杂的项目，可以考虑采用以包或者蓝图(Blueprints)的方式组织你的项目。模块 Modules我的项目 requirements.txt 是这个样子：Flask==0.10.1Flask-RESTful==0.3.5Flask-SQLAlchemy==2.1Flask-Marshmallow==0.6.2Marshmallow-Sqlalchemy==0.8.1PyMySQL==0.7.2Gunicorn==19.4.5APScheduler==3.0.5FlaskFlask 不必多说，当前的最新版本 0.10.1。同时支持 Python 3 和 Python 2。不过 Armin Ronacher, Flask 的作者原话如下： 我自己现在并不用它，我也不会向别人推荐自己都不相信的东西，所以我不会推荐 Python 3.如果你打算将 Flask 应用到生产环境并且不想面对开发了几个月后发现自己不能使用包 X, Y, Z 的话，还是采用 Python2 环境比较好。但是，秉着“要啥自行车，先整个最新的”态度，我还是使用了 Pyhton 3… 因为项目用到的几个模块都已经官方支持 Python 3。Flask-RESTfulFlask-RESTful 是 FLask 的一个扩展，使用它能快速的构建 REST APIs。同类型的模块还有好几个，都是帮助你少写一些重复代码，我随便挑了一个。官方文档提供了中英双版本，勉强算一个优点吧。Flask-SQLAlchemy, Flask-Marshmallow and Marshmallow-Sqlalchemy这三个放在一起讲不是因为不重要，恰恰相反，它们搭配起来能大大简化数据的持久化、序列化等工作。三者联系紧密，你一定不想错过它们。Flask-SQLAlchemySQLAlchemy 是 Flask 上使用最广泛的 ORM 模块。官方更新勤快，功能强大，性能稳定优宜。你还有什么理由不用它？Flask-SQLAlchemy 为 Flask 提供了扩展支持，使你更轻松的使用 SQLAlchemy。它提供了对 SQLAlchemy 的一些默认配置，帮助你少写些代码。Flask-MarshmallowMarshmallow 一个轻量级的序列化/反序列化库，用于将复杂对象与 Python 数据类型相互转换。而 Flask-Marshmallow 增加了一些扩展特性，包括支持 HATEOAS-ready APIs 的 URL 和 Hyperlinks fields(不知这个词该怎么翻译…)。Marshmallow-SqlalchemyMarshmallow-Sqlalchemy 能帮 Sqlalchemy 自动生成 Marshmallow 视图。同样也是为了少写些代码(懒人的境界)。PyMySQLPython 实现的 Mysql 的驱动。Flask 支持绝大部分主流数据库，关系型数据库 MySQL, PostgreSQL等等，非关系型数据库如 MongoDB, Redis 等等。我这里使用了 Mysql。Gunicorn虽然 Flask 自带着 WSGI server, 但是性能不太好，更多的是测试用途。发布时则使用生产环境的 WSGI server 或者是联合 Nginx 做 Uwsgi 。Gunicorn 是一个 Python WSGI UNIX 的 HTTP 服务器。与各种Web框架兼容，只要简单配置执行，轻量级的资源消耗，就能运行的相当迅速。下面是我用到的网络框架模型(图片来源：峰云，就她了)，由 Nginx pass_proxy 到 app 的前端口，然后用 Gunicorn 来协同处理 。Network frameworkAPSchedulerAPScheduler 定时任务框架，实现了Quartz的所有功能。提供了基于日期、固定时间间隔以及 Crontab 类型的任务，并且可以持久化任务。我用来跑一些定时任务，发统计数据到 Slack, 导出备份数据库，启动爬虫之类。代码Talk is cheap 对不对，最后把 app.py 文件贴出来。其实业务非常简单，仔细阅读过官方文档的话理解起来很轻松。Gist: app.py" }, { "title": "Retrofit2 使用及新特性", "url": "/posts/awesome-retrofit2-you-should-know/", "categories": "Android", "tags": "retrofit2", "date": "2016-04-29 08:14:33 +0800", "snippet": "最近 Retrofit2 正式版发布了（当前版本号已经小幅更新到2.0.2），带来了相当多的新特性，内部也默认使用 Okhttp3 作为网络请求库。使用的便捷性比 Retrofit1 再次向前迈了一步。下面总结了几个自己用到的新特性。Call2.0 支持了在一个类型中的同步和异步。只需要使用新的 call 方法。interface GitHubService { @GET(&quot;/repos/{owner}/{repo}/contributors&quot;) Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; repoContributors( @Path(&quot;owner&quot;) String owner, @Path(&quot;repo&quot;) String repo);}Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; call = gitHubService.repoContributors(&quot;square&quot;, &quot;retrofit&quot;);这里是一个同步请求。语法和 OkHttp 基本一模一样，唯一不同是这个函数知道如何做数据的反序列化。它知道如何将 HTTP 响应转换成对象。方便很多是不是，在很多简单场景下甚至可以不用再引入 Gson 或 Jackson 了(当然你也可以轻松的用 Gson 等序列化库替换它)。需要注意的是，每一个 call 对象实例只能被用一次，所以说 request 和 response 都是一一对应的。你其实可以通过 Clone 方法来创建一个一模一样的实例，这个开销是很小的。比如说：你可以在每次决定发请求前 clone 一个之前的实例。Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; call = gitHubService.repoContributors(&quot;square&quot;, &quot;retrofit&quot;);response = call.execute();// This will throw IllegalStateException:response = call.execute();// Clone to get new objectCall&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; call2 = call.clone();// This will not throw:response = call2.execute();动态 URL Parameter在涉及到分页时，这个特性十分有用。例如向 GitHub 发出多个请求，收到一个响应，通常这个响应大概像下面这样：interface GitHubService { @GET(&quot;/repos/{owner}/{repo}/contributors&quot;) Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; repoContributors( @Path(&quot;owner&quot;) String owner, @Path(&quot;repo&quot;) String repo);}Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; call = gitHubService.repoContributors(&quot;square&quot;, &quot;retrofit&quot;);Response&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; response = call.execute();// HTTP/1.1 200 OK// Link: &amp;lt;https://api.github.com/repositories/892275/contributors?page=2&amp;gt;; rel=&quot;next&quot;, &amp;lt;https://api.github.com/repositories/892275/contributors?page=3&amp;gt;; rel=&quot;last&quot;// ...在 Retrofit 1.0 的时候，我们没有办法去直接执行 GitHub Server 返回在 header 里的请求地址。由于动态 URL 地址就是用在连续请求里的。在第一个请求之后，如果返回的结果里有指明下个请求的地址的话，在之前，你可能得单独写个 interface 来处理这种情况，现在就无需那么费事了。interface GitHubService { @GET(&quot;/repos/{owner}/{repo}/contributors&quot;) Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; repoContributors( @Path(&quot;owner&quot;) String owner, @Path(&quot;repo&quot;) String repo); @GET Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; repoContributorsPaginate( @Url String url);}Retrofit 2.0 有了新的 标注：@Url ，允许你直接传入一个请求的 URL。有了这个方法后，我们就可以直接把刚才取出来的下一页的地址传入，是不是一切都流畅了很多：String nextLink = nextFromGitHubLinks(links);// https://api.github.com/repositories/892275/contributors?page=2Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; nextCall = gitHubService.repoContributorsPaginate(nextLink);这样的话，就能通过调用 repoContributorsPaginate 来获取第二页内容，然后通过第二页的 header 来请求第三页。Retrofit2 是不是很强大？还有更多新特性等待发掘。推荐浏览库作者之一 Jake Wharton 的演讲记录—— Simple HTTP with Retrofit 2，里面干货众多(Android 开源大牛深度就是不一样，科科)。另外推荐 Realm.io ，上面分享的文章常常质量都不错。本文部分引用 Simple HTTP with Retrofit 2 -A talk from Droidcon NYC 2015" } ]
